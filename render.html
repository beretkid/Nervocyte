<div id="sky"style=" background-image: url('Assets/skybox.png'); 
    background-repeat: repeat; 
    border: 0px;
    background-position: 0px bottom; 
    background-origin: padding-box;
	position: fixed; 
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    margin: 0;
	background-Size: 228px 228px;
    padding: 0;
	 z-index: -1;"></div>
<div id="debug" z-index:10></div>
<script type="importmap">
  {
    "imports": {
        "three": "https://unpkg.com/three/build/three.module.js",
      "three/addons/": "https://unpkg.com/three/examples/jsm/"
    }
  }
</script>
<body></body>
<script type="module" id="renderer">
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import * as THREE from 'three';
  import { STLLoader } from 'three/addons/loaders/STLLoader.js'; 

  // --- Initializing Variables (Standardized to Radians/Defaults) ---
  function project3Dto2D(objectX, objectY, objectZ, viewDistance, canvasWidth, canvasHeight) {
    // Check if the object is in front of the camera/view plane
    if (objectZ <= viewDistance) {
        // Handle objects behind the camera, or too close (clipping)
        // You might choose not to draw them.
        return null; 
    }

    // Calculate the scaling factor based on depth
    // The further the object (larger objectZ), the smaller the scale
    const scale = viewDistance / objectZ;

    // Project the 3D coordinates to 2D screen coordinates (relative to the center)
    const screenX = objectX * scale;
    const screenY = objectY * scale;

    // Adjust coordinates to be relative to the top-left corner of the canvas
    const finalX = screenX + canvasWidth / 2;
    const finalY = screenY + canvasHeight / 2; // Note: Canvas y usually goes down

    return { x: finalX, y: finalY, scale: scale };
}

  var i = 0
  var pct = 0
  var viewbob = 0
  var camturn = 0
  const debugText = document.getElementById("debug")
  var moving = false
  // Initialize camera orientation variables in RADIANS
  var camup = 0;   
  const sky = document.getElementById("sky")
  var camright = 0; 
  var ambientShart = 0
  // Define a consistent rotation speed in RADIANS (approx 2 degrees per update)
  const rotationSpeed = Math.PI / 180 * 2;

  const canvas = document.getElementById('visuals');
  const ctx = canvas.getContext("2d");
  const hphs = document.getElementById("hphs")
  var pressedKeys = []
     const textureLoader = new THREE.TextureLoader();

  window.addEventListener('message', (event) => {
    pressedKeys = event.data.pressedKeys
  })

  canvas.width = window.innerWidth * 1
  canvas.height = window.innerHeight * 1
  var w = canvas.width;
  var h = canvas.height;

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  // CRITICAL FIX: Set Euler order to YXZ for proper FPS controls once at setup

    var upVector = new THREE.Vector3(0, 1, 0); // Fuck whoops that was a const
  // Define the X-axis vector globally once (for movement calculations if needed later)
  var sideVector = new THREE.Vector3(1, 0, 0);
  const renderer = new THREE.WebGLRenderer({alpha:true});
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.domElement.id = "wawa"
  document.body.appendChild( renderer.domElement );

  var light = new THREE.AmbientLight( 0x404040 ); 
  scene.add( light );
  const color1 = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );
  const color2 = new THREE.Color().setRGB( 0.6, 0.6, 0.6 );
  const light2 = new THREE.HemisphereLight( color1, color2, 1 );
scene.add( light2 );
  const entities = []
  const geometry2 = new THREE.BoxGeometry( 1000, 1000, 1 );
  const material2 = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );

  // The degToRad function is no longer needed if we use radians everywhere
  /* function degToRad(degrees) {
    return degrees * (Math.PI / 180);
  } */
  //load textures
    const texture = textureLoader.load('Assets/TerrainTexture.png');
	texture.wrapS = THREE.RepeatWrapping;
texture.wrapT = THREE.RepeatWrapping;
	texture.repeat.set(100, 100); // Repeat 4 times horizontally and vertically
    const groundtex = new THREE.MeshStandardMaterial({
        map: texture
		
    });


const cloader = new THREE.CubeTextureLoader();

// 2. Load the six image files in the correct order


// 2. Define your texture paths in order: [+X, -X, +Y, -Y, +Z, -Z]
const skybx = "Assets/skybox.png"
const textureCube = cloader.load([
    skybx, // Right
    skybx, // Left
    skybx, // Top
    skybx, // Bottom
    skybx, // Front
    skybx  // Back
]);

  scene.background = textureCube;
    //add skybox
    //textureLoader.load( 'Assets/skybox.png', (texture) => {
	
    //scene.background 
    //})
	
  const floor = new THREE.Mesh(geometry2, groundtex);
  scene.add(floor);
  floor.position.set(0, 0, 0); // Cleaner way to set position
  
  const loader = new STLLoader();

  loader.load(
    'Assets/b02.stl', 
	  
    function (geometry) {
        const material = new THREE.MeshStandardMaterial({ color: 0x363636 });
        const cube = new THREE.Mesh(geometry, material);
        cube.scale.set(10, 10, 10)
        scene.add(cube);
        console.log('Model loaded successfully!');
        renderer.setAnimationLoop( animate );
        cube.position.y = 5
        camera.position.z = 4;
       camera.rotation.x = Math.PI / 2; // 1.5708 radians
    },
    undefined, 
    function (error) {
        console.error('An error occurred while loading the model:', error);
    }
  );
    
  var wdown = false
  var adown = false
  var sdown = false
  var ddown = false
 
  function animate() {
    var curr
    var cpx = camera.position.x
    var cpy = camera.position.z

    ctx.clearRect(0,0,1000,1000)
    //for (i in entities) {
      //ctx.fillStyle = "White"
      //dist = 5
      //ctx.fillRect(camright/dist, 0,10,10)
      //camright is the players turning, please ignore all other values.
    //}
    
    //upVector = new THREE.Vector3(0, camright, 0);
     
    if (pressedKeys["ArrowLeft"]) { 
      // Rotate around the world's UP axis (Y axis) relative to current orientation
      
      camera.rotateOnAxis(upVector, rotationSpeed); 
      camright += rotationSpeed
    }
    if (pressedKeys["ArrowRight"]) { 
       // Rotate the other way
     
      camera.rotateOnAxis(upVector, -rotationSpeed); 
       camright += -rotationSpeed
    }
  var moveSpeed = 0.1;
        if (pressedKeys["ShiftLeft"] ) { 
          moveSpeed = 0.2;
        } else {
           moveSpeed = 0.1;
        }

camera.position.z = 4+(Math.sin(Math.sin(viewbob*1.2)*1.25)*0.1)

 	sky.style.backgroundPositionX = ((camright*360)+ambientShart)+'px';
    debugText.innerHTML = "X: " + cpx + " Y: " cpy
    renderer.render( scene, camera );

    ambientShart += 0.1
    moving = false
    if (pressedKeys["KeyS"]) {
      // Moves backward along the camera's local Z-axis
      camera.translateZ(moveSpeed); 
      moving = true
    }
    if (pressedKeys["KeyW"]) {
      // Moves forward along the camera's local Z-axis
      camera.translateZ(-moveSpeed); 
      moving = true
    }
    if (pressedKeys["KeyA"]) {
      // Moves left along the camera's local X-axis
      camera.translateX(-moveSpeed);
      moving = true
    }
    if (pressedKeys["KeyD"]) {
      // Moves right along the camera's local X-axis
      camera.translateX(moveSpeed);
      moving = true
    }
    if (moving) {
      viewbob += moveSpeed
    }



  }
  
  var changex = 0
  var changey = 0
  var prevx = 0
  var prevy = 0 

  ctx.fillStyle = "red"
  ctx.fillRect(0,0,50,50)

</script>

<canvas id="visuals" width="100%" height="100"% style="z-index: 10;position:absolute;top:0%;left:0%;border:2px solid;border-color:#0f0f0f"></canvas>

<style>
#wawa {
  position: absolute;
  top: 0%;
  left: 0%;
  font-size: 28px;
  font-family: monospace;
}
</style>
